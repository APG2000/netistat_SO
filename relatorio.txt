# Introdução

O script netistat.sh monitoriza as diferentes interfaces, calculando a quantidade de tráfico que passa em cada uma delas num determinado intervalo de tempo.

### Opções

A visualização estará formatada numa tabela com um cabeçalho seguido das interfaces organizadas por ordem alfabética.
opção -c
Esta opção será seguida de uma string que será um regex ultilizado para selecionar a interface de rede.
opção -b
Visualização em bytes
opção -m
Visualização em megabytes
opção -t
Ordenar interfaces por ordem de bytes tranmitidos TX
opção -r
Ordenar interfaces por ordem de bytes recebidos RX
opção -R
Ordenar interfaces por frequencia de bytes RRATE mb/s ou b/s
opção -T
Ordenar interfaces por frequencia de receção TRATE mb/s ou b/s
opção -v
Ordenar pela ordem contrária (reverse)
opção -l
Correr o programa em loop de s segundos
### Intenções inicias e workarrounds

O ideal para este problema seria um mapa ou um array bidimensional mas como a bash não suporta essas estruturas nativamente, inicialmente pensamos em usar três arrays para amazernar os diferentes valores de rx,t x e as  interfaces, o que funcionaria corretamente se não houvesse a possibilidade de ser adicionada uma interface a meio do programa (os indices das interfaces não iam corresponder aos indices dos valores). Então para resolver o problema criamos uma estrutura a que chamamos de dicform que é semelhante a um dicionário em python ou um Map em Java, este é um array de strings que aceita como indices strings.

#Recolha de informação

### Interfaces

 for inter in $(ifconfig -a | grep -E "inet|ether" -v | grep : | awk '{print $1}' | cut -d ":" -f1); do 
    interfaces+=($inter)
 done

O ifconfig dá nos a informação das interfaces. Todas interfaces têm uma coisa em commum têm dois pontos á frente dela, para chegarmos a elas redirecionamos a informação do ifconfig dando "pipe"->| e ultilizamos o comando "grep :" que seleciona as linhas com as interfaces, no entanto vêm atrás as linhas com ipv6 e a palavra ether pelo que antes a informação do ifconfig é redirecionada para um outro comando onde fazemos uma seleção inversa para  tirar essas linhas ("grep -E "inet|ether") . Agora que temos as linhas onde a primeira coluna são interfaces podemos obtelas dando “pipe”  para o awk  e o argumento “{print $1}” que é uma linguagem  para processamento de texto inbutida na shell, e aqui o estamos a fazer é só passar do pipe como argumeto para o comando de awk print $1 que nos imprime a primeira coluna, depois disso paenas tiramos o dois pontos dando pipe para o comando pipe.
Quando fazemos isto ficamos com uma coluna onde cada linha é uma interface, passando este output para uma variável obtemos um array com as interfaces que depois percorremos no com o for adicionando á variável interfaces.

###  TX e RX

Ao todo temos 3 dicionários 2 que amazernam as informações no inicio no de cada intervalo e no fim de cada intervalo repétivamente(dicform_i; dicform_f), e outro as informações desde que corremos o programa para as situações de loop(dicform_r).  Sendo que obtemos as informações para essas estruturas com os seguintes comandos:

for i in "${interfaces[@]}"; do
        dicform[$i]=$(ifconfig $i  | grep packets | grep TX | awk '{print $5}')
        dicform[$i]+=":"$(ifconfig $i  | grep packets | grep RX | awk '{print $5}')
done

Percorremos cada interface pra buscar os valores de tx e rx como nas interfaces usamos o grep e awk para ir buscar a informação que nos interessa , primeiro selecionamos todas as linhas que têm packets , isto porque se ultilizasse-mos bytes e houvesse queda de pacotes iriam aparecer colunas extra, depois selecionamos por repétivamente TX e RX buscando os bytes imprimindo a quinta coluna e cocantenado esta informação criamos uma string com uma formatação especifica para posterior facil acesso. Sendo essa formatação a seguinte “tx:rx”

# Funções e blocos  

O programa está dividido em varias funções e blocos de codico que se interligam entre si.

assert() - verifica se o numero de argumentos é valido e se o argumento passado como segundos é um numero inteiro

getinterfaces() - reúne num array todas as interfaces no sistema

getdicform() - obtém os dados mais recentes fornecidos pelo ifconfig para o dicform_f
ciclo getops - lê as opções introduzidas pelo utilizador  até ao primeiro argumento não opção. Usa uma string que começa por “:” onde cada letra é opção e se tiver “:” têm um argumento que precisa de ser lido.
Dentro deste ciclo são definidas as opções “order_of_sort” para o sort  que vai receber o pipe do print_dados(). Além disso atribui valores aos atributos “loop” que nos indica se existe loop ou não;  “opv” que nos indica o tipo de dados (0-b;1-kb;2-mb);  “grepby” e “c_option” que indicam ao programa para dar pipe do print_dados() para o o grep seguido do regex da opção c e “reverse” que inverte a ordem anterior establecida e ao head que é argumento e comando a que damos o ultimo pipe que nos limita o numero de linhas do output e por sua vez o numero de interfaces

print_dados() - Aqui é onde o output é formado.
Começamos por chamar a função getdicform para obter os dados mais recentes. 
Dentro do ciclo obtemos o output relativo a cada interface, primeiro obtemos o linhas dos dicionarios inicial , final , e desde do startup. Apartir dessas linhas obtemos o valor inicial e final de rx e tx (rx_i,tx_i,rx_f,tx_f), e subtraindo os valores obtemos o rx e tx a imprimir, além desses calculamos o valor total caso se trate de um loop  somando os valores que estavam no dicionario dicform_r aos (tx_inicial;rx_inicial) aos valores atuais formando os valores totais de bytes de rx e tx (tx_total;rx_total); e ainda o Rrate e TRate dividindo rx e tx pelo tempo , nestes ultimos assim como todas as divisões recorremos ao comando bc que recebendo pipe de uma string com calculo e certeza calcula o resultado.
Ainda dentro do ciclo apartir da variável opv fazemos um switch case onde conforme o valor calculamos o valor a imprimir em bytes , kb , mb  e dentro desse case temos dois prints possíveis conforme o valor de loop , se loop for 1 fazemos o print com os valores totais se não fazemos o print normal.
Saindo do switch case  atualizamos o dicform_r com os novos valores totais.

Initial_setup() - como o nome diz é uma função unicamente usado no inicio da execução do programa para introduzir os dados no dicionário inicial (dicform_i) e preencher com zeros o dicionario com os dados desde do startup (dicform_r), além disso é imprimido o primeiro cabeçalho e é executado o comando sleep $s em que $s é o intervalo de tempo

the_real_thing - este nome foi o que demos á ultima secção de codico pois é nela que tudo acontece á parte do processamento de opções e o setup_inicial aqui é nos apresentado uma condição que verifica se existe loop, e se tal corre um ciclo infinito que são imprimidos os dados e redefenidos valores iniciais a cada iteração , se não imprime uma unica vez os dados. Em ambas as opções estes dados são passados por múltiplos pipes conforme as opções defenidas no getops.

# Fluxo

A execução de funções  e blocos de códico pode ser abstractamente representada  por este “fluxograma”

assert() -> getops -> initial_setup() ->  the_real_thing -> print_dados()^n , n€[1,+infinito]

# Testes feitos

Normal
./netistat.sh 4
Loop/Mb/
./netistat.sh -l -m 4
Interfaces/Kb/tx
./netistat.sh -p 3 -c “w” -k -t 4
Interfaces/b/p/reverse
./netistat.sh -b -p 3 -v 4

# Conclusão

Com este trabalho ficamos com uma melhor compreensão de como a bash shell apesar de uma linguagem simples sem estruturas complexas e uma sintaxe única com indentações por vezes irregulares  ao contrário da maioria das linguagens de programação, é uma ferramenta poderosa para interagir com sistema operativo capaz de processar outputs e inputs de diferentes programas e comandos selecionado e transformando-os com as diferentes opções possíveis sendo perfeita para interagir com outras linguagens executando binarios e processando os resultados para decidir o que fazer. 
